<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized Minecraft World</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>
        let scene, camera, renderer, clock;
        let player, controls;
        const worldWidth = 100, worldHeight = 10, worldDepth = 100;
        const blockSize = 1;
        const visibleRange = 25; // Limit rendering to a 25-block radius

        // Initialize Scene
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Add lighting for better visuals
            const light = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(light);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 50, 10);
            scene.add(directionalLight);

            // Generate the world
            generateWorld();

            // Add the player
            createPlayer();

            // Set the initial camera position
            camera.position.set(50, 10, 50);

            // Handle user input
            setupInput();

            // Start rendering loop
            animate();
        }

        // Generate a simplified world
        function generateWorld() {
            const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

            const materials = {
                stone: new THREE.MeshBasicMaterial({ color: 0x808080 }),
                dirt: new THREE.MeshBasicMaterial({ color: 0x6E4B3A }),
                grass: new THREE.MeshBasicMaterial({ color: 0x228B22 })
            };

            const blockGroup = new THREE.Group();

            for (let x = 0; x < worldWidth; x++) {
                for (let y = 0; y < worldHeight; y++) {
                    for (let z = 0; z < worldDepth; z++) {
                        let material = materials.stone;

                        if (y === 0) material = materials.dirt; // Dirt layer
                        if (y === 1 && Math.random() < 0.01) material = materials.grass; // Random trees

                        if (y <= 1) { // Only render layers near the surface
                            const block = new THREE.Mesh(blockGeometry, material);
                            block.position.set(x * blockSize, y * blockSize, z * blockSize);
                            blockGroup.add(block);
                        }
                    }
                }
            }

            scene.add(blockGroup);
        }

        // Create the player
        function createPlayer() {
            const geometry = new THREE.BoxGeometry(0.6, 1.8, 0.6);
            const material = new THREE.MeshBasicMaterial({ color: 0x00FF00 });
            player = new THREE.Mesh(geometry, material);
            player.position.set(worldWidth / 2, 2, worldDepth / 2); // Start in the middle
            scene.add(player);
        }

        // Handle player input
        const keys = {};
        function setupInput() {
            document.addEventListener('keydown', (event) => keys[event.key] = true);
            document.addEventListener('keyup', (event) => keys[event.key] = false);
        }

        // Handle player movement
        const velocity = new THREE.Vector3();
        function movePlayer(delta) {
            const speed = 5;
            if (keys['w']) velocity.z = -speed * delta; // Forward
            if (keys['s']) velocity.z = speed * delta; // Backward
            if (keys['a']) velocity.x = -speed * delta; // Left
            if (keys['d']) velocity.x = speed * delta; // Right

            player.position.add(velocity);
            camera.position.set(player.position.x, player.position.y + 2, player.position.z + 5);
            velocity.set(0, 0, 0); // Reset velocity
        }

        // Render loop
        function animate() {
            const delta = clock.getDelta(); // Time since last frame
            movePlayer(delta); // Update player position
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Initialize everything
        init();
    </script>
</body>
</html>
