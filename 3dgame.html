<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel World with Gravity and Block Placement</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Set up basic scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Setup for player control and gravity
        let isJumping = false;
        let velocity = new THREE.Vector3();
        const gravity = -0.1;
        const jumpStrength = 2;

        // Create a simple cube (block)
        function createBlock(x, y, z, color) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            scene.add(block);
        }

        // Create a world of blocks
        function createWorld() {
            for (let x = -5; x < 5; x++) {
                for (let y = 0; y < 2; y++) {
                    for (let z = -5; z < 5; z++) {
                        createBlock(x, y, z, 0x00ff00); // Green blocks
                    }
                }
            }
        }

        // Player controls (WASD movement)
        let moveSpeed = 0.1;
        let cameraSpeed = 0.05;
        let lookSpeed = 0.002;
        let isMouseLocked = false;

        let mouseX = 0, mouseY = 0;

        document.addEventListener('mousemove', (event) => {
            if (isMouseLocked) {
                mouseX = (event.movementX / window.innerWidth) * 2; 
                mouseY = (event.movementY / window.innerHeight) * 2;
            }
        });

        // Mouse lock for FPS-style camera look
        function updateCameraLook() {
            camera.rotation.y -= mouseX * lookSpeed; // Rotate horizontally
            camera.rotation.x -= mouseY * lookSpeed; // Rotate vertically
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x)); // Limit vertical rotation
        }

        // Simple jump
        document.addEventListener('keydown', (event) => {
            if (event.key === "w") velocity.z = -moveSpeed;
            if (event.key === "s") velocity.z = moveSpeed;
            if (event.key === "a") velocity.x = -moveSpeed;
            if (event.key === "d") velocity.x = moveSpeed;
            if (event.key === " " && !isJumping) jump();
        });

        document.addEventListener('keyup', (event) => {
            if (event.key === "w" || event.key === "s") velocity.z = 0;
            if (event.key === "a" || event.key === "d") velocity.x = 0;
        });

        // Jumping function
        function jump() {
            if (camera.position.y <= 1) {
                isJumping = true;
                velocity.y = jumpStrength;
            }
        }

        // Collision detection and gravity effect
        function applyGravity() {
            velocity.y += gravity;
            camera.position.y += velocity.y;

            // Prevent the player from falling through the world
            if (camera.position.y <= 1) {
                camera.position.y = 1;
                velocity.y = 0;
                isJumping = false;
            }
        }

        // Detect block placement on click
        document.addEventListener('mousedown', (event) => {
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const raycaster = new THREE.Raycaster(camera.position, direction);
            const intersects = raycaster.intersectObject(scene, true);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const blockX = Math.floor(point.x);
                const blockY = Math.floor(point.y);
                const blockZ = Math.floor(point.z);

                // Add a block at the intersection point
                createBlock(blockX + 1, blockY, blockZ, 0x00ff00);
            }
        });

        // Lock mouse on mouse click for FPS-style control
        document.addEventListener('click', () => {
            if (!isMouseLocked) {
                document.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
                document.requestPointerLock();
                isMouseLocked = true;
            }
        });

        // Camera position and world creation
        camera.position.set(0, 1, 5);
        createWorld();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update camera rotation based on mouse movement
            updateCameraLook();

            // Apply gravity and handle player movement
            applyGravity();

            // Move the player based on camera orientation (WASD)
            camera.position.x += velocity.x;
            camera.position.z += velocity.z;

            // Render the scene
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
